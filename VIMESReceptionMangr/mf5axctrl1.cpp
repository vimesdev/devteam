// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "mf5axctrl1.h"
#include ".\mf5axctrl1.h"


DWORD WINAPI MF5AXThreadFnc( LPVOID lpParam ) 
{ 
printf("\r\nxxx");
	CMf5axctrl1 *pCtrl = (CMf5axctrl1*) lpParam;
	if(pCtrl)
		pCtrl->RunLoop();
    return 0; 
} 


/////////////////////////////////////////////////////////////////////////////
// CMf5axctrl1

IMPLEMENT_DYNCREATE(CMf5axctrl1, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CMf5axctrl1 properties

/////////////////////////////////////////////////////////////////////////////
// CMf5axctrl1 operations
BEGIN_MESSAGE_MAP(CMf5axctrl1, CWnd)
	ON_WM_DESTROY()
END_MESSAGE_MAP()

void CMf5axctrl1::OnDestroy()
{
	mfHalt();
	SetPortOpen(FALSE);
	WaitForSingleObject(m_hThread, INFINITE);
	CloseHandle(m_hThread);
	m_bTerminated  = TRUE;
	CWnd::OnDestroy();
	
}

void CMf5axctrl1::RunLoop(){
	printf("\r\nTHreading");
	for(;;)
	{
		if(m_bTerminated && !GetCommPort())
			break;
		long request = mfRequest();
		if(request > 0){
	printf("\r\nrequest; %ld", request);
							//if(mfAnticollision())
							{
								CString szCardID = get_mfAnticollisionHex();
								if(!szCardID.IsEmpty())
								{
									_tprintf(_T("\r\nCardID=%s: %ld"), szCardID, mfRequest);
								}
								
							}

		}
		
	}
}

BOOL CMf5axctrl1::PreTranslateMessage(MSG* pMsg)
{
	// TODO: Add your specialized code here and/or call the base class
	
	return CWnd::PreTranslateMessage(pMsg);
}

BOOL CMf5axctrl1::OnCommand(WPARAM wParam, LPARAM lParam)
{
	// TODO: Add your specialized code here and/or call the base class

	return CWnd::OnCommand(wParam, lParam);
}
